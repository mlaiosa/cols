#!/usr/bin/env python

import sys, pprint

def whitespace_prefix(s):
	r""" Given a string s, return the longest prefix of s that consists solely
	of whitespace 
	
	>>> whitespace_prefix(' dogs ')
	' '
	>>> whitespace_prefix('\tdogs ')
	'\t'
	>>> whitespace_prefix('dogs')
	''
	>>> whitespace_prefix('')
	''
	>>> whitespace_prefix('    ')
	'    '
	"""
	for i in xrange(len(s)):
		if not s[i].isspace():
			return s[:i]
	return s


def common_prefix(l):
	""" Given a list of strings, return the longest common prefix of all
	strings.  common_prefix([]) == "" by definition. 

	>>> common_prefix([])
	''
	>>> common_prefix(["a","b","c"])
	''
	>>> common_prefix([" a", "  b", "   c"])
	' '
	>>> common_prefix(["", "asdf"])
	''
	>>> common_prefix(["singleton"])
	'singleton'
	"""
	l = iter(l)
	prefix = ""
	try:
		prefix = l.next()
		while len(prefix) > 0:
			string = l.next()
			while not string.startswith(prefix):
				prefix = prefix[:-1]
	except StopIteration:
		pass
	return prefix

def next_cell(s):
	"""Split a string into two parts - the contents of the next cell, and the
	part of the string that comes after the next cell.  A few doc-tests are
	provided in order to better document its interface than I can do with
	prose; integration tests have primary responsiblity for testing this
	function.

	>>> next_cell("a b c d")
	('a', ' b c d')
	>>> next_cell(' b c d')
	('b', ' c d')
	>>> next_cell(' d')
	('d', '')
	>>> next_cell('')
	('', '')
	>>> next_cell(' ')
	('', '')

	"""
	# Skip leading whitespace
	quote_count = 0
	s = s.lstrip()
	for i, ch in enumerate(s):
		if ch == '"':
			if quote_count == 2:
				# There are too many quotes.  Redo this ignoring quotes.
				r = s.split()[0].strip()
				return (r, s[len(r):])
			quote_count += 1
		if ch.isspace() and quote_count != 1:
			return (s[:i], s[i:])
	return (s, "")

def split_row(s, num_cols=None):
	"""Split a row into multiple cells

	>>> split_row("a b c d e f g")
	['a', 'b', 'c', 'd', 'e', 'f', 'g']
	>>> split_row("  a b c d e f g  ")
	['a', 'b', 'c', 'd', 'e', 'f', 'g']
	>>> split_row("")
	[]
	>>> split_row("    ")
	[]

	"""
	row = []
	while True:
		if len(row)+1 == num_cols:
			row.append(s.strip())
			return row
		cell, s = next_cell(s)
		if cell == "":
			return row
		row.append(cell)

class Options(object):
	num_cols     = None
	align_equals = False

def parse_args():
	o = Options()
	if len(sys.argv) <= 1:
		return o
	if sys.argv[1] == '=':
		o.align_equals = True
	else:
		try: o.num_cols = int(sys.argv[1])
		except ValueError: pass
	return o

def main():
	lines = sys.stdin.readlines()
	opts = parse_args()

	# Determine the prefix and strip it off.  Remove trailing whitespace while
	# we're at it.
	prefix = common_prefix(line for line in lines if line.strip() != "")
	prefix = whitespace_prefix(prefix)
	rows = [split_row(line, opts.num_cols) for line in lines]

	if opts.align_equals:
		equals_columns = [None]*len(rows)
		for i, row in enumerate(rows):
			try: equals_columns[i] = row.index('=') - 1
			except ValueError: pass
		equals_column = max(equals_columns)
		if equals_column is not None:
			for i, row in enumerate(rows):
				eq = equals_columns[i]
				if eq is not None and eq < equals_column:
					cols_to_insert = equals_column-eq
					eq = max(0, eq)
					row[eq:eq] = [""] * cols_to_insert

	num_columns = 0
	for row in rows:
		num_columns = max(num_columns, len(row))

	column_widths = [0]*num_columns
	for row in rows:
		for i in xrange(len(row)):
			column_widths[i] = max(column_widths[i], len(row[i]))
	
	for row in rows:
		sys.stdout.write(prefix)
		for i, cell in enumerate(row):
			if i == len(row) - 1:
				sys.stdout.write(cell)
			else:
				sys.stdout.write("%*s" % (-column_widths[i]-1, cell))
		sys.stdout.write("\n")

if __name__ == "__main__":
	main()
